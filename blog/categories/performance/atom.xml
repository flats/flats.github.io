<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: performance | Basic Object]]></title>
  <link href="http://flats.github.io/blog/categories/performance/atom.xml" rel="self"/>
  <link href="http://flats.github.io/"/>
  <updated>2016-01-05T00:54:22-05:00</updated>
  <id>http://flats.github.io/</id>
  <author>
    <name><![CDATA[D. Flaherty]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Frozen Strings, Symbols, and Garbage Collection in Ruby]]></title>
    <link href="http://flats.github.io/blog/2016/01/03/frozen-strings/"/>
    <updated>2016-01-03T03:21:09-05:00</updated>
    <id>http://flats.github.io/blog/2016/01/03/frozen-strings</id>
    <content type="html"><![CDATA[<p>I was perusing <a href="https://github.com/thoughtbot/paperclip">the paperclip gem’s source code</a> when I came upon the following line (lib/paperclip/interpolations.rb, line 178):</p>

<p><code>ruby
("%09d".freeze % id).scan(/\d{3}/).join("/".freeze)
</code></p>

<p>It’s a useful bit of code for saving attachments to a filesystem, but what struck me immediately was the preponderance of <code>#freeze</code> calls. What the hell is <code>#freeze</code> anyway?</p>

<p>Well, apparently <code>#freeze</code> is used pretty often by experienced Ruby developers. It’s a method of the <code>Object</code> class, and <a href="http://ruby-doc.org/core-2.3.0/Object.html#method-i-freeze">“it prevents further modifications” of an object</a>. You’ll see it especially in popular Gems that have gone through several versions and have a large number of contributors.</p>

<p>There are a couple of reasons you might want to use it. Here they are.</p>

<h3 id="make-an-object-immutable">Make an Object Immutable</h3>

<p>Ruby constants are really just variables that you shouldn’t change. Ruby will warn you if you change a constant, but it won’t raise an exception. So, if you really want to have Ruby enforce the constancy of a constant, you can freeze that object.</p>

<p><code>ruby
JEDI_MASTER = "Kenobi".freeze
JEDI_MASTER.prepend("Rey ") # =&gt; RuntimeError: can't modify frozen String
</code></p>

<p>Remember that when you assign a frozen object to a variable, this does not prevent the variable from being reassigned to another object. The following code, for example, works just fine:</p>

<p><code>ruby
JEDI_MASTER = "Kenobi".freeze
JEDI_MASTER = "Rey Kenobi"
</code></p>

<p>You can extend this to create a whole class of objects that are constant from birth - just call <code>#freeze</code> at the end of a class’s initialize function definition. This might come in handy if you’re <a href="http://blog.honeybadger.io/when-to-use-freeze-and-frozen-in-ruby/">trying to write Ruby in a functional style</a>.</p>

<h3 id="performance">Performance</h3>

<p>As great as this is, this is not why the paperclip developers use <code>#freeze</code> three times in that line at the beginning of this post.</p>

<p>They use it to <a href="http://www.sitepoint.com/unraveling-string-key-performance-ruby-2-2/">optimize for performance</a>. Ruby treats frozen strings similarly to the way it treats symbols (which, along with fixnums, bignums, and floats, are frozen by default) - it will allocate one and only one object for each frozen string in an application’s lifetime. (This is not strictly true in newer versions of Ruby, but it’s pretty close to that - there are more details in the article below about symbol garbage collection in Ruby 2.2.) Therefore, if you freeze the string literals you don’t ever intend to modify in a method (such as <code>"/"</code> and the format string <code>"%09d"</code> in the example above) that gets called multiple times, Ruby will allocate those string objects the first time the method is called and then just reference those existing object on every subsequent call.</p>

<p>Because this improves performances and reduces memory requirements considerably, Ruby is moving in the direction of freezing strings by default. Starting with Ruby 2.2, strings used as hash keys are frozen by default, and Ruby 3.0 will freeze all string literals by default. You can see what life is like with frozen string literals right now with the frozen_string_literal pragma, which is <a href="https://blog.blockscore.com/new-features-in-ruby-2-3/">available in Ruby 2.3 or later</a>.</p>

<p>So why not just use symbols all of the time? Well, for starters, you might want to use some <code>String</code> methods! The <code>#%</code>, <code>#scan</code>, and <code>#join</code> calls in the example above wouldn’t be possible with symbols. Ruby strings are powerful and converting a string to a symbol is pretty slow, so it’s better to just use a string and freeze it where appropriate.</p>

<p>In addition, as Richard Schneeman points out in <a href="http://www.sitepoint.com/unraveling-string-key-performance-ruby-2-2/">his excellent post about string keys in Ruby 2.0</a>, creating symbols based on user input can lead to a particular sort of denial of service attack and other potential security problems. <a href="https://www.ruby-lang.org/en/news/2013/02/22/json-dos-cve-2013-0269/">The JSON gem suffered from this vulnerability before Ruby 2.0.0</a>, and Mr. Schneeman has some other examples of this vulnerability in <a href="http://www.sitepoint.com/symbol-gc-ruby-2-2/">his post about symbol garbage collection in Ruby 2.2</a>.</p>

<hr />

<p>Even though Ruby will soon be freezing strings by default, the absolute fastest way to freeze a string is to do it manually. Embrace it. It’s the low-hanging fruit of Ruby optimization. So, when you’ve written an application or a gem or anything in Ruby and you’re looking to speed it up or reduce its memory footprint, look to <code>#freeze</code>.</p>
]]></content>
  </entry>
  
</feed>
