<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Basic Object]]></title>
  <link href="http://flats.github.io/atom.xml" rel="self"/>
  <link href="http://flats.github.io/"/>
  <updated>2015-12-07T09:26:34-05:00</updated>
  <id>http://flats.github.io/</id>
  <author>
    <name><![CDATA[D. Flaherty]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    
    <title type="html"><![CDATA[Getting to Know Ruby's Map and Reduce]]></title>
    <link href="http://flats.github.io/blog/2015/12/02/getting-to-know-rubys-map-and-reduce/"/>
    
    <updated>2015-12-02T21:27:10-05:00</updated>
    <id>http://flats.github.io/blog/2015/12/02/getting-to-know-rubys-map-and-reduce</id>
    
    <content type="html"><![CDATA[<p>Map and reduce are most closely associated with functional programming[^1]. Even so, Ruby, the object-oriented-est of all object-oriented programming languages, has robust implementations of both of these extremely expressive higher-order functions. I’m going to explore a bit of what you can do with them.</p>

<h1 id="first-the-basics">First, the Basics</h1>

<p>As higher-order functions, each of these methods accepts a function in the form of a block. They then iterate over an enumerable object and call this block on each iteration. Where they differ is in what they do with the result of this block.</p>

<p><code>map</code> (or <code>collect</code>) returns an array containing the results of calling the supplied block on each element of the enumerable. In other words, map allows you to apply a function to every element of a data structure and receive the result.</p>

<p><code>reduce</code> (or <code>inject</code>) returns a value that is the result of applying a binary operation to the return value of applying the supplied block to each element of the enumerable. Whoa. What a mouthful. In other words, <code>reduce</code> “reduces” each element of an enumerable to a single value, accumulates that value in a single variable, and then returns the value of the accumulator. Some functional languages, such Scheme and OCaml, refer to this as <code>fold</code>.</p>

<h1 id="some-interesting-map-and-reduce-examples">Some Interesting Map and Reduce Examples</h1>

<p>These functions are very powerful when used together. First, I’ll look at a cool example of using <code>map</code> on its own, but then I’ll get into some uses of reduce chained on to the end of map.</p>

<p>In his <a href="http://www.sitepoint.com/functional-programming-techniques-with-ruby-part-i/">series on functional programming in Ruby</a>, Nathan Kleyn mentions a question that Yehuda Katz asked several years ago about splitting a module path in a particular way. <a href="http://rubyquicktips.com/post/1018776470/embracing-functional-programming">One solution proposed by Bradley Grzesiak</a> demonstrates a particularly interesting use of reduce:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">module_name = "X::Y::Z"
</span><span class="line">module_name.split('::').inject([]) { |memo,x| memo.unshift(memo.empty? ? x : "#{memo[0]}::#{x}") }
</span><span class="line">=&gt; ["X::Y::Z", "X::Y", "X"]</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Let’s break this code down into separate steps.</p>

<ol>
  <li>
    <p>Mr. Grzesiak splits <code>module_name</code>, which is our starting string, into the array [“X”, “Y”, “Z”].</p>
  </li>
  <li>
    <p>He then uses the <code>inject</code> using the <code>inject(initial)</code> syntax, which will initialize the accumulator, called <code>memo</code>, to an empty array.</p>
  </li>
  <li>
    <p>Now the iteration begins. If this new ‘memo’ array is empty, which will only happen on the first iteration of <code>inject</code>, <code>inject</code> adds that element (“X”) to the beginning of <code>memo</code> (using <code>unshift</code>). Otherwise, <code>inject</code> adds a string to <code>memo</code> containing the result of the previous iteration (“X”), the separator (“::”), and the current element (“Y”).</p>
  </li>
</ol>

<p>So, the final array is built backwards: [“X”], then [“X::Y”, “X”], and then finally [“X::Y::Z”, “X::Y”, “X”]. Nifty.</p>

<hr />

<p>Haitham Mohammad put <code>transpose</code> <a href="http://rubyquicktips.com/post/18842314838/some-array-magic-using-transpose-map-and-reduce">through its paces</a> on <a href="http://rubyquicktips.com/">Ruby Quicktips</a>, the same site that gave us the above solution. <code>transpose</code>, <a href="http://ruby-doc.org/core-2.2.0/Array.html#method-i-transpose">according to the Ruby documentation</a>, “assumes that self is an array of arrays and transposes the rows and columns.” In other words, if you imagine an array of arrays as rows in a table, <code>transpose</code> will return the columns from that table.</p>

<p>Mr. Mohammad then shows us how to get the sum of each column of table represented by an array of row arrays.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class=""><span class="line">a = [1, 2, 3]
</span><span class="line">b = [4, 5, 6]
</span><span class="line">c = [7, 8, 9]
</span><span class="line">
</span><span class="line">[a, b, c].transpose.map { |x| x.reduce :+ }
</span><span class="line"># =&gt; [12, 15, 18]</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>[^1] <a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)">Lisp</a>, one of the oldest high-level programming languages, pioneered the use of higher-order functions. While it supports several different programming paradigms, Lisp and its most popular dialects, Common Lisp and Scheme, are most commonly used to program in the functional programming paradigm.</p>
]]></content>
    
  </entry>
  
</feed>